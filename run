#!/usr/bin/env bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
IMAGE_NAME="${DOCKER_IMAGE_NAME:-cs147-verilog-toolchain}"
CONFIG_FILE_HOST="$REPO_ROOT/config.json"
CONFIG_SCRIPT_HOST="$REPO_ROOT/student_config.py"
CONFIG_FILE_CONT="/repo/config.json"
CONFIG_SCRIPT_CONT="/repo/student_config.py"
TEST_FORCE=""

# Normalize paths on MSYS/Git Bash (Windows)
if command -v cygpath >/dev/null 2>&1; then
  SCRIPT_DIR="$(cygpath -u "$SCRIPT_DIR")"
  REPO_ROOT="$(cygpath -u "$REPO_ROOT")"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "Error: Docker is not installed or not on PATH. Install Docker Desktop and try again." >&2
  exit 1
fi

if [ -z "$REPO_ROOT" ]; then
  echo "Error: run must be executed inside the CS_147_Handouts git repository." >&2
  exit 1
fi

case "$PWD/" in
  "$REPO_ROOT/"*) ;;
  *)
    echo "Error: current directory ($PWD) is not inside the repository root ($REPO_ROOT)." >&2
    exit 1
    ;;
esac

REL_PATH="${PWD#"$REPO_ROOT"}"
REL_PATH="${REL_PATH#/}"
WORKDIR="/repo"
[ -n "$REL_PATH" ] && WORKDIR="/repo/$REL_PATH"

DOCKER_SOCK_VOLUME=()
if [ -S /var/run/docker.sock ]; then
  DOCKER_SOCK_VOLUME=(-v /var/run/docker.sock:/var/run/docker.sock)
fi
TTY_FLAGS=()
if [ -t 0 ] && [ -t 1 ]; then
  TTY_FLAGS=(-it)
fi
SELFTEST_LOG_DIR="$REPO_ROOT/assignments/.testing/selftest_logs"

run_with_spinner() {
  label="$1"; shift
  start_ts=$(date +%s)
  "$@" &
  cmd_pid=$!
  if [ -t 1 ]; then
    i=0
    while kill -0 "$cmd_pid" 2>/dev/null; do
      elapsed=$(( $(date +%s) - start_ts ))
      mins=$((elapsed / 60)); secs=$((elapsed % 60))
      case $i in
        0) spin_char='|' ;;
        1) spin_char='/' ;;
        2) spin_char='-' ;;
        3) spin_char='\\' ;;
      esac
      printf "\r  [INFO] %s: %s %02d:%02d" "$label" "$spin_char" "$mins" "$secs"
      i=$(( (i + 1) % 4 ))
      sleep 0.2
    done
    wait "$cmd_pid"; rc=$?
    elapsed=$(( $(date +%s) - start_ts ))
    mins=$((elapsed / 60)); secs=$((elapsed % 60))
    printf "\r  [INFO] %s completed in %02d:%02d\n" "$label" "$mins" "$secs"
    return $rc
  else
    wait "$cmd_pid"; rc=$?
    elapsed=$(( $(date +%s) - start_ts ))
    mins=$((elapsed / 60)); secs=$((elapsed % 60))
    printf "  [INFO] %s completed in %02d:%02d\n" "$label" "$mins" "$secs"
    return $rc
  fi
}

print_help() {
  cat <<'EOF'
./run commands:
  ./run setup                  Build the Docker image (uses DOCKER_IMAGE_NAME override if set), then prompt for your name.
  ./run shell                  Start an interactive shell in the container at the matching repo subdirectory.
  ./run <cmd>                  Run any command inside the container (e.g., make test, iverilog ...).
  ./run help                   Show this help plus top-level make targets.
  ./run verilog_checker <tgt>  Run Vcheck on an assignment or path (see verilog_checker.sh for details).
  ./run submit <assignment>    Run the assignment submit flow.
  ./run wave_test              Generate VCD waveforms for the .testing mux examples.
  ./run test <hw> [sub]        Run assignment testbenches (all subproblems or one if specified).
  ./run student_name           View/update the recorded student name.
  ./run clean_turnins          Delete generated submission archives (prompts).
  ./run clean_docker           Remove toolchain/autograder images (prompts; optional config cleanup).
  ./run clean                  Run all clean_* targets and remove local self-test logs.
EOF
}

if [ "${1:-}" = "help" ] || [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ] || [ "${1:-}" = "--help-only" ]; then
  print_help
  if [ "${1:-}" != "--help-only" ] && [ -z "${RUN_HELP_SKIP_MAKE:-}" ]; then
    RUN_HELP_SKIP_RUN=1 make -s -C "$REPO_ROOT" help
  fi
  exit 0
fi

if [ "${1:-}" = "verilog_checker" ]; then
  shift
  exec docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w "$WORKDIR" "$IMAGE_NAME" bash /repo/verilog_checker.sh "$@"
fi

if [ "${1:-}" = "test" ]; then
  shift
  exec docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w /repo "$IMAGE_NAME" bash /repo/assignments/.testing/test_runner.sh "$@"
fi

case "${1:-}" in
  submit)
    target="$1"; shift
    nograde="0"
    justgrade="0"
    submit_verbose="0"
    assignment_arg=""
    declare -a extra_make_args=()
    # Parse flags anywhere; first non-flag hw* is the assignment.
    while [ "$#" -gt 0 ]; do
      case "$1" in
        -nograde) nograde="1" ;;
        -justgrade) justgrade="1" ;;
        -v|--verbose) submit_verbose="1" ;;
        hw[0-9]*) if [ -z "$assignment_arg" ]; then assignment_arg="$1"; else extra_make_args+=("$1"); fi ;;
        *) extra_make_args+=("$1") ;;
      esac
      shift
    done
    if [ -z "$assignment_arg" ]; then
      echo "[submit] assignment name required (e.g., hw01)" >&2
      exit 1
    fi
    if [ ${#extra_make_args[@]} -gt 0 ]; then
      set -- "$assignment_arg" "${extra_make_args[@]}"
    else
      set -- "$assignment_arg"
    fi
    # Run submit inside the container first.
    docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w /repo -e NOGRADE="$nograde" -e JUSTGRADE="$justgrade" -e AG_VERBOSE="$submit_verbose" -e MAKEFLAGS="--no-print-directory -s" "$IMAGE_NAME" make "$target" "$@"
    rc=$?
    if [ $rc -ne 0 ]; then
      exit $rc
    fi
    # Host-side autograder run unless -nograde
    if [ "$nograde" = "1" ]; then
      echo "[submit] host autograder skipped (nograde)"
      exit 0
    fi
    # Normalize hw number (accept hw1 or hw01)
    case "$assignment_arg" in
      hw[0-9]) assignment_arg=$(printf "hw%02d" "${assignment_arg#hw}") ;;
    esac
    marker_path="$REPO_ROOT/assignments/$assignment_arg/.last_submit_zip"
    if [ ! -f "$marker_path" ]; then
      echo "[submit] marker file not found for host autograder: $marker_path" >&2
      exit 1
    fi
    rel_entry=$(cat "$marker_path")
    zip_name="${rel_entry##*/}"
    grader_dir="$REPO_ROOT/assignments/$assignment_arg/Gradescope_Autograder_Template"
    if [ ! -d "$grader_dir" ]; then
      echo "[submit] Gradescope_Autograder_Template not found for $assignment_arg; skipping host autograder." >&2
      exit 1
    fi
    echo "[submit] running host autograder..."
    (cd "$grader_dir" && AG_VERBOSE="$submit_verbose" ./run grade "test_submissions/$zip_name")
    grade_rc=$?
    echo "[submit] cleaning autograder artifacts..."
    (cd "$grader_dir" && make clean >/dev/null 2>&1 || true)
    exit $grade_rc
    ;;
  clean_turnins|clean_docker|clean|student_name|wave_test)
    target="$1"; shift
    exec docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w /repo "$IMAGE_NAME" make "$target" "$@"
    ;;
esac

ensure_student_name() {
  # Uses container python, so call after image exists.
  current_name="$(docker run --rm -v "$REPO_ROOT:/repo" -w /repo "$IMAGE_NAME" python3 "$CONFIG_SCRIPT_CONT" --config "$CONFIG_FILE_CONT" current 2>/dev/null || true)"
  if [ -n "$current_name" ]; then
    echo "Student name: $current_name"
    return
  fi
  printf "Enter your name (for submissions): "
  read -r new_name
  if [ -z "$new_name" ]; then
    echo "Name cannot be empty." >&2
    exit 1
  fi
  docker run --rm -v "$REPO_ROOT:/repo" -w /repo "$IMAGE_NAME" python3 "$CONFIG_SCRIPT_CONT" --config "$CONFIG_FILE_CONT" set --name "$new_name"
  echo "Recorded student name: $new_name"
}

if [ "${1:-}" = "setup" ]; then
  shift
  while [ $# -gt 0 ]; do
    case "$1" in
      --test-force=*)
        TEST_FORCE="${1#*=}"
        ;;
      *)
        echo "Unknown setup option: $1" >&2
        exit 1
        ;;
    esac
    shift
  done
  echo "Building Docker image '$IMAGE_NAME'..."
  docker build -t "$IMAGE_NAME" -f "$REPO_ROOT/docker/Dockerfile" "$REPO_ROOT"
  echo "Docker image '$IMAGE_NAME' is ready."
  ensure_student_name
  echo "------------------------------------------------------------"
  echo "[SELF-TEST] .testing"
  echo "============================================================"
  mkdir -p "$SELFTEST_LOG_DIR"
  attempt=1
  set +e  # allow retries even when commands fail inside the loop
  while [ $attempt -le 3 ]; do
    echo "---------------- attempt $attempt/3 ----------------"
    log_file="$SELFTEST_LOG_DIR/.testing_selftest_attempt${attempt}.log"
    if run_with_spinner "Self-test attempt $attempt" docker run --rm -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w /repo "$IMAGE_NAME" bash -lc "set -e; make submit .testing ${TEST_FORCE:+FORCE_RESULT=\"$TEST_FORCE\"}" >"$log_file" 2>&1; then
      cat "$log_file"
      echo "============================================================"
      echo "[SELF-TEST] PASS"
      echo "------------------------------------------------------------"
      exit 0
    else
      if [ $attempt -lt 3 ]; then
        echo "(attempt $attempt failed; output saved to $log_file)"
      else
        cat "$log_file"
      fi
    fi
    echo "---------------- end attempt $attempt ----------------"
    attempt=$((attempt+1))
  done
  set -e
  echo "============================================================"
  echo "[SELF-TEST] FAIL after 3 attempts. Please contact the instructor."
  if ls "$SELFTEST_LOG_DIR"/.testing_selftest_attempt*.log >/dev/null 2>&1; then
    echo "Saved logs:"
    ls -1 "$SELFTEST_LOG_DIR"/.testing_selftest_attempt*.log
  fi
  echo "------------------------------------------------------------"
  exit 1
fi

if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
  echo "Error: Docker image '$IMAGE_NAME' not found. Run './run setup' first." >&2
  exit 1
fi

if [ $# -eq 0 ]; then
  set -- shell
fi

if [ "$1" = "shell" ]; then
  shift
  exec docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w "$WORKDIR" "$IMAGE_NAME" bash "$@"
fi

exec docker run --rm "${TTY_FLAGS[@]}" -v "$REPO_ROOT:/repo" "${DOCKER_SOCK_VOLUME[@]}" -w "$WORKDIR" "$IMAGE_NAME" "$@"
